#!/bin/bash

# GitHub integration functions for Strata GitHub Action
# This module handles GitHub-specific functionality like PR comments, step summaries, and outputs

# Function to process markdown content for different GitHub contexts
process_markdown_for_context() {
  local context=$1  # "step-summary" or "pr-comment"
  local content="$2"
  
  case "$context" in
    "step-summary")
      # Add step summary specific enhancements
      echo "# $COMMENT_HEADER"
      echo ""
      echo "$content"
      echo ""
      add_workflow_info
      ;;
    "pr-comment")
      # Add PR comment specific enhancements
      echo "## $COMMENT_HEADER"
      echo ""
      echo "<!-- strata-comment-id: $GITHUB_WORKFLOW-$GITHUB_JOB -->"
      echo ""
      echo "$content"
      echo ""
      add_pr_footer
      ;;
    *)
      echo "$content"
      ;;
  esac
}

# Function to add workflow information for step summaries
add_workflow_info() {
  echo "<details>"
  echo "<summary>ℹ️ Workflow Information</summary>"
  echo ""
  echo "- **Repository:** $GITHUB_REPOSITORY"
  echo "- **Workflow:** $GITHUB_WORKFLOW"
  echo "- **Run ID:** $GITHUB_RUN_ID"
  echo "- **Strata Version:** $("$TEMP_DIR"/"$BINARY_NAME" --version | head -n 1)"
  echo ""
  echo "</details>"
  echo ""
  echo "---"
  echo "*Generated by [Strata](https://github.com/ArjenSchwarz/strata)*"
}

# Function to add PR comment footer
add_pr_footer() {
  echo "---"
  echo "*Generated by [Strata](https://github.com/ArjenSchwarz/strata) in [workflow run](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID})*"
}

# Function to optimize content for specific contexts
optimize_content_for_context() {
  local context=$1
  local content="$2"
  
  case "$context" in
    "step-summary")
      # Add collapsible sections for better organization
      echo "$content" | add_collapsible_sections
      ;;
    "pr-comment")
      # Limit content size for PR comments
      echo "$content" | limit_content_size 65000
      ;;
    *)
      echo "$content"
      ;;
  esac
}

# Function to add collapsible sections to large content blocks
add_collapsible_sections() {
  local content
  content=$(cat)
  
  # If content is longer than 2000 characters, wrap sections in collapsible details
  if [ ${#content} -gt 2000 ]; then
    # Look for section headers (lines starting with ##) and wrap content
    echo "$content" | awk '
      BEGIN { in_section = 0; section_content = ""; section_header = "" }
      /^## / {
        if (in_section) {
          if (section_content != "") {
            print "<details>"
            print "<summary>" section_header "</summary>"
            print ""
            print section_content
            print ""
            print "</details>"
            print ""
          } else {
            # Output header-only sections without collapsible wrapper
            print section_header
            print ""
          }
        }
        section_header = $0
        section_content = ""
        in_section = 1
        next
      }
      {
        if (in_section) {
          section_content = section_content $0 "\n"
        } else {
          print $0
        }
      }
      END {
        if (in_section) {
          if (section_content != "") {
            print "<details>"
            print "<summary>" section_header "</summary>"
            print ""
            print section_content
            print ""
            print "</details>"
          } else {
            # Output header-only sections without collapsible wrapper
            print section_header
          }
        }
      }
    '
  else
    echo "$content"
  fi
}

# Function to limit content size for PR comments
limit_content_size() {
  local max_size=$1
  local content
  content=$(cat)
  
  if [ ${#content} -gt "$max_size" ]; then
    # Calculate truncation point (try to break at a reasonable place)
    local truncate_point=$((max_size - 200))
    local truncated_content="${content:0:$truncate_point}"
    
    # Try to find a good break point (end of line)
    local last_newline
    last_newline=$(echo "$truncated_content" | grep -n $'\n' | tail -1 | cut -d: -f1)
    
    if [ -n "$last_newline" ] && [ "$last_newline" -gt $((truncate_point - 500)) ]; then
      truncated_content=$(echo "$content" | head -n "$last_newline")
    fi
    
    echo "$truncated_content"
    echo ""
    echo "<details>"
    echo "<summary>⚠️ Content truncated due to size limits</summary>"
    echo ""
    echo "The full output was too large for a GitHub comment. "
    echo "Please check the [workflow run](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}) for complete details."
    echo ""
    echo "</details>"
  else
    echo "$content"
  fi
}

# Function to post PR comment with proper error handling
post_pr_comment() {
  local pr_number=$1
  local comment_body="$2"
  
  log "Posting PR comment" "PR: $pr_number, Size: ${#comment_body} chars"
  
  # Check if we should update existing comment
  if [ "$UPDATE_COMMENT" = "true" ]; then
    # Function to make GitHub API request with retry
    github_api_request() {
      local method=$1
      local url=$2
      local data=$3
      local max_attempts=3
      local attempt=1
      local response
      
      while [ $attempt -le $max_attempts ]; do
        log "API request attempt $attempt/$max_attempts" "$method $url"
        
        # Check for rate limiting
        local rate_limit_check
        rate_limit_check=$(curl -s -I -H "Authorization: token $GITHUB_TOKEN" "${GITHUB_API_URL}/rate_limit")
        local remaining
        remaining=$(echo "$rate_limit_check" | grep -i "x-ratelimit-remaining" | cut -d':' -f2 | tr -d ' \r\n')
        
        # Validate remaining is numeric before using in arithmetic
        if [ -n "$remaining" ] && [[ "$remaining" =~ ^[0-9]+$ ]] && [ "$remaining" -le 5 ]; then
          local reset_time
          reset_time=$(echo "$rate_limit_check" | grep -i "x-ratelimit-reset" | cut -d':' -f2 | tr -d ' \r\n')
          
          # Validate reset_time is numeric before using in arithmetic
          if [ -n "$reset_time" ] && [[ "$reset_time" =~ ^[0-9]+$ ]]; then
            local current_time
            current_time=$(date +%s)
            local wait_time
            wait_time=$((reset_time - current_time + 5))
            
            if [ "$wait_time" -gt 0 ]; then
              warning "Rate limit almost reached ($remaining remaining). Waiting for $wait_time seconds before retry."
              sleep "$wait_time"
            fi
          fi
        fi
        
        # Make the request
        if [ -z "$data" ]; then
          response=$(curl -s -w "%{http_code}" -X "$method" -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" "$url")
        else
          response=$(curl -s -w "%{http_code}" -X "$method" -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" -d "$data" "$url")
        fi
        
        local http_status
        http_status=${response: -3}
        
        # Check for success
        if [ "$http_status" -lt 400 ]; then
          echo "$response"
          return 0
        fi
        
        # Check for rate limiting
        if [ "$http_status" -eq 403 ] && echo "${response%???}" | grep -q "rate limit"; then
          local reset_time
          reset_time=$(echo "${response%???}" | jq -r '.rate.reset' 2>/dev/null || echo 0)
          local current_time
          current_time=$(date +%s)
          local wait_time
          wait_time=$((reset_time - current_time + 5))
          
          if [ "$wait_time" -gt 0 ]; then
            warning "Rate limit reached. Waiting for $wait_time seconds before retry."
            sleep "$wait_time"
            attempt=$((attempt))
            continue
          fi
        fi
        
        # For other errors, retry with backoff
        attempt=$((attempt + 1))
        if [ $attempt -le $max_attempts ]; then
          sleep_time=$((2 ** (attempt - 1)))
          warning "API request failed with status $http_status. Retrying in ${sleep_time}s"
          sleep $sleep_time
        else
          warning "API request failed after $max_attempts attempts with status $http_status"
          echo "$response"
          return 1
        fi
      done
      
      return 1
    }
    
    # Search for existing comment
    local comments_url="${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/issues/${pr_number}/comments"
    log "Searching for existing comments" "URL: $comments_url"
    
    local comments_response
    comments_response=$(github_api_request "GET" "$comments_url")
    local http_status=${comments_response: -3}
    
    if [ "$http_status" -ge 400 ]; then
      warning "Failed to fetch existing comments, creating new comment instead"
      local comment_id=""
    else
      local comments=${comments_response%???}
      local comment_id
      comment_id=$(echo "$comments" | jq -r ".[] | select(.body | contains(\"strata-comment-id: $GITHUB_WORKFLOW-$GITHUB_JOB\")) | .id" 2>/dev/null)
    fi
    
    if [ -n "$comment_id" ]; then
      # Update existing comment
      log "Updating existing comment" "ID: $comment_id"
      local comment_url="${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/issues/comments/${comment_id}"
      local response
      response=$(github_api_request "PATCH" "$comment_url" "{\"body\": $(echo "$comment_body" | jq -R -s .)}")
      local update_status=${response: -3}
      
      if [ "$update_status" -ge 400 ]; then
        warning "Failed to update comment (HTTP $update_status), creating new comment instead"
        
        # Try to create new comment as fallback
        local fallback_response
        fallback_response=$(github_api_request "POST" "$comments_url" "{\"body\": $(echo "$comment_body" | jq -R -s .)}")
        local fallback_status=${fallback_response: -3}
        
        if [ "$fallback_status" -ge 400 ]; then
          warning "Both comment update and creation failed"
        else
          log "Successfully created new comment after update failure"
        fi
      else
        log "Successfully updated existing comment"
      fi
    else
      # Create new comment
      log "Creating new comment"
      local response
      response=$(github_api_request "POST" "$comments_url" "{\"body\": $(echo "$comment_body" | jq -R -s .)}")
      local create_status=${response: -3}
      
      if [ "$create_status" -ge 400 ]; then
        warning "Failed to create comment: HTTP $create_status"
      else
        log "Successfully created new comment"
      fi
    fi
  else
    # Always create new comment
    log "Creating new comment"
    local comments_url="${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/issues/${pr_number}/comments"
    local response
    response=$(github_api_request "POST" "$comments_url" "{\"body\": $(echo "$comment_body" | jq -R -s .)}")
    local create_status=${response: -3}
    
    if [ "$create_status" -ge 400 ]; then
      warning "Failed to create comment (HTTP $create_status)"
    fi
  fi
}

# Function to distribute content to different GitHub contexts
distribute_output() {
  local stdout_output="$1"
  local markdown_content="$2"
  
  log "Starting output distribution to GitHub contexts" "Stdout size: ${#stdout_output} chars, Markdown size: ${#markdown_content} chars"
  
  # Prepare base content with statistics for both contexts
  local base_content=""
  
  # Add dynamic header with job and workflow information
  local workflow_job_info=""
  if [ -n "$GITHUB_WORKFLOW" ] && [ -n "$GITHUB_JOB" ]; then
    workflow_job_info="📋 **Terraform Plan Summary** - $GITHUB_WORKFLOW / $GITHUB_JOB"
  else
    workflow_job_info="📋 **Terraform Plan Summary**"
  fi
  base_content="$workflow_job_info

"
  
  
  
  # Use the complete Strata output directly without additional headers
  local main_content_section=""
  if [ -n "$markdown_content" ]; then
    main_content_section="$markdown_content"
  else
    main_content_section="$stdout_output"
  fi
  
  # No separate details section needed - details are included in main output when show_details=true
  local details_section=""
  
  # Write to GitHub Step Summary using processed markdown content
  if [ -n "$GITHUB_STEP_SUMMARY" ]; then
    log "Processing content for GitHub Step Summary" "Target: $GITHUB_STEP_SUMMARY"
    
    # Prepare step summary content
    local step_summary_content="${base_content}${main_content_section}${details_section}"
    
    # Process content for step summary context
    local processed_step_summary
    processed_step_summary=$(process_markdown_for_context "step-summary" "$step_summary_content")
    
    # Skip optimization for step summary to preserve table formatting
    local sanitized_step_summary
    sanitized_step_summary=$(sanitize_github_content "$processed_step_summary")
    
    # Write to step summary
    echo "$sanitized_step_summary" >> "$GITHUB_STEP_SUMMARY"
    log "Step summary written successfully" "Size: ${#sanitized_step_summary} chars"
  else
    log "GitHub Step Summary not available" "GITHUB_STEP_SUMMARY environment variable not set"
  fi
  
  # Handle PR comments if enabled
  if [ "$COMMENT_ON_PR" = "true" ] && [ "$GITHUB_EVENT_NAME" = "pull_request" ]; then
    log "Processing content for PR comment" "Event: $GITHUB_EVENT_NAME"
    
    # Extract PR number from GitHub event
    local pr_number
    pr_number=$(jq -r .pull_request.number "$GITHUB_EVENT_PATH" 2>/dev/null)
    
    if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
      # Prepare PR comment content
      local pr_comment_content="${base_content}"
      
      # Use markdown content if available, otherwise use stdout
      if [ -n "$markdown_content" ]; then
            pr_comment_content="${pr_comment_content}${markdown_content}"
      else
        pr_comment_content="${pr_comment_content}${stdout_output}"
      fi
      
      pr_comment_content="${pr_comment_content}

${details_section}"
      
      # Process content for PR comment context
      local processed_pr_comment
      processed_pr_comment=$(process_markdown_for_context "pr-comment" "$pr_comment_content")
      
      # Optimize and sanitize content
      local optimized_pr_comment
      optimized_pr_comment=$(optimize_content_for_context "pr-comment" "$processed_pr_comment")
      local sanitized_pr_comment
      sanitized_pr_comment=$(sanitize_github_content "$optimized_pr_comment")
      
      # Post the PR comment
      log "Posting PR comment" "PR number: $pr_number, Content size: ${#sanitized_pr_comment} chars"
      post_pr_comment "$pr_number" "$sanitized_pr_comment"
    else
      warning "Could not determine PR number, skipping PR comment"
    fi
  else
    if [ "$COMMENT_ON_PR" != "true" ]; then
      log "PR commenting disabled" "COMMENT_ON_PR setting: $COMMENT_ON_PR"
    else
      log "Not in pull request context" "GITHUB_EVENT_NAME: $GITHUB_EVENT_NAME"
    fi
  fi
  
  # Set action outputs with appropriate content for each output type
  log "Setting GitHub Action outputs" "Preparing outputs for workflow consumption"
  
  # Create a simple one-line summary from table output
  local summary_line="Terraform Plan Analysis Complete"
  set_output "summary" "$summary_line"
  log "Action output set" "summary: $summary_line"
  
  
  # Set markdown content as additional output for GitHub features
  if [ -n "$MARKDOWN_CONTENT" ]; then
    set_output "markdown-summary" "$MARKDOWN_CONTENT"
    log "Action output set" "markdown-summary: ${#MARKDOWN_CONTENT} chars (markdown format)"
  else
    log "Markdown summary output skipped" "No markdown content available"
  fi
  
  log "GitHub Action outputs completed" "All outputs set successfully"
  log "Output distribution completed successfully" "All targets processed"
}